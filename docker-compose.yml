# Указываем версию синтаксиса docker-compose. 3.8 - хорошая современная версия.
version: '3.8'

# Здесь мы описываем сервисы (контейнеры), которые составляют наше приложение.
services:
  # Наш первый и пока единственный сервис - база данных. Назовем его 'db'.
  db:
    # Какой образ использовать для создания контейнера. Мы берем официальный образ PostgreSQL 15-й версии.
    # 'alpine' - это легковесная версия, которая занимает меньше места.
    image: postgres:15-alpine
    # Политика перезапуска. 'always' означает, что Docker будет пытаться перезапустить контейнер, если он упадет.
    restart: always
    # Здесь мы передаем переменные окружения внутрь контейнера.
    # Образ postgres использует их для первоначальной настройки.
    environment:
      # ${POSTGRES_USER} - docker-compose возьмет значение переменной POSTGRES_USER
      # из нашего файла .env и передаст его в контейнер.
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
    # Проброс портов. Мы "пробрасываем" порт 5432 внутри контейнера
    # на порт, указанный в нашей переменной POSTGRES_PORT (тоже из .env) на нашей локальной машине.
    # Это позволяет нашему приложению, запущенному на localhost, "видеть" базу в контейнере.
    ports:
      - "${POSTGRES_PORT}:5432"
    # Тома (Volumes). Это способ сохранять данные даже после удаления контейнера.
    # Мы создаем именованный том 'postgres_data' и "монтируем" его в папку,
    # где PostgreSQL хранит свои данные.
    volumes:
      - postgres_data:/var/lib/postgresql/data

# Здесь мы описываем тома, которые используем.
volumes:
  postgres_data:
    # Оставляем пустым, чтобы Docker сам управлял этим томом.